coordinate_frames {
  #root frame is what everything is drawn in, hence ENU
  root_frame = "local";

  #body pose as defined by the state estimator
  body {
    relative_to = "local";
    history = 1000;
    pose_update_channel = "STATE_ESTIMATOR_POSE";
    initial_transform{
      translation = [0, 0, 0];
      rpy = [0, 0, 0];
    }
  }

  body_vicon {
    relative_to = "local";
    history = 1000;
    pose_update_channel = "VICON_POSE";
    initial_transform{
      translation = [0, 0, 0];
      rpy = [0, 0, 0];
    }
  }

  body_desired {
    relative_to = "local";
    history = 1000;
    pose_update_channel = "CONTROLLER_DESIRED_POSE";
    initial_transform{
      translation = [0, 0, 0];
      rpy = [0, 0, 0];
    }
  }

  # Andy: this is used in the INS handler in the state estimator
  ardupilot2 {
    relative_to = "body";
    history = 1000;
    initial_transform {
        translation = [0, 0, 0];
        #rpy = [180,0,0];
        rpy = [180,0,0];

    }
  }

  cameraL {
    relative_to = "body";
    history = 1000;
    initial_transform {
        translation = [0, 0, 0]; #FIXME
        rpy = [0,0,0];

    }
  }

  opencvFrame {
    relative_to = "cameraL";
    history = 1000;
    initial_transform {
        translation = [0, 0, 0];
        rpy = [-90,0,-90]; # when you do roll, pitch, yaw for these frames, you are moving
                           # the frame in the global coordinate, not it's own local "roll"
                           # ie think about taking the coordinate itself and moving it
                           # while looking at it, regardless of what orientation it is in

    }
  }

  optotrak_temp {
    relative_to = "local";
    history = 1000;
    initial_transform {
        translation = [0, 0, 0];
        rpy = [0,0,0];

    }
  }

  optotrak_temp2 {
    relative_to = "optotrak_temp";
    history = 1000;
    initial_transform {
        translation = [0, 0, 0];
        rpy = [0,0,0];

    }
  }

  optotrak {
    relative_to = "optotrak_temp2";
    history = 1000;
    initial_transform {
        translation = [0, 0, 0];
        #translation = [2.4741274, -0.13677342, 0.1121641];
        rpy = [0,0,0];

    }
  }

    # this transform exists so you can have two representations
    # of the body: "local" and "optotrak-local"
    optotrak-local {
    relative_to = "local";
    history = 1000;
    initial_transform {
        translation = [0, 0, 0];
        rpy = [0,0,0];

    }
  }

  #current - 7/21/2012 04 onward
  microstrain {
    relative_to = "body";
    history = 1000;
    initial_transform {
        translation = [0, 0, 0];
        rpy = [0,0,180];

    }
  }


  #current - 7/21/2012 logs 00-03 && 7/14/2012 - 9/16/2011
  microstrain_02 {
    relative_to = "body";
    history = 1000;
    initial_transform {
        translation = [0, 0, 0];
        rpy = [0,180,0];

    }
  }

  #7/20/2012 - 7/15/2012
  microstrain_01 {
    relative_to = "body";
    history = 1000;
    initial_transform {
        translation = [0, 0, 0];
        rpy = [180,0,0];

    }
  }

  #everything before 9/15/2011
  microstrain_old {
    relative_to = "body";
    history = 1000;
    initial_transform {
        translation = [0, 0, 0];
        rpy = [90, 0, 0];

    }
  }

  ublox_gps {
    relative_to = "local";
    history = 10000;
    initial_transform{
      translation = [0, 0, 0];
      rpy = [0, 0, 0];
    }
  }

  right_ail {
    relative_to = "body";
    history = 0;
    initial_transform{
      translation=[0, -0.5, -.1];
      rpy = [0, 0, 0];
    }
  }

  left_ail {
    relative_to = "body";
    history = 0;
    initial_transform{
      translation=[0, 0.5, -.1];
      rpy = [0, 0, 0];
    }
  }

  elevator {
    relative_to = "body";
    history = 0;
    initial_transform{
      translation=[-.9, 0, 0];
      rpy = [0, 0, 0];
    }
  }

  rudder {
    relative_to = "body";
    history = 0;
    initial_transform{
      translation=[-.8, 0, .15];
      rpy = [0, 0, 0];
    }
  }

# One Hokuyo UTM-30LX LIDAR
  laser {
    relative_to = "body";
    history = 0;
    initial_transform{
      translation = [ 0, 0, 0 ]; #sits on top of IMU
      rpy = [ 0, 0, 0 ];
    }
  }

  #simulation frames
  sim_body_gt {
    relative_to = "local";
    history = 1000;
    pose_update_channel = "SIM_POSE_GT";
    #pose_update_channel = "STATE_ESTIMATOR_POSE";
    initial_transform{
      translation = [0, 0, 0];
      rpy = [0, 0, 0];
    }
  }

  sim_laser {
    relative_to = "sim_body_gt";
    history = 0;
    initial_transform{
      translation = [ 0, 0, 0 ];
      rpy = [ 0, 0, 0 ];
    }
  }

}

state_estimator {

    # ins,vicon, pose_meas
    init_sensors = ["ins"];
    # laser_gpf, ins, rgbd_gpf, fovis, legodo , vicon, pose_meas
    active_sensors = ["ins", "altimeter", "airspeed", "sideslip", "init_message"];

    pose_channel = "STATE_ESTIMATOR_POSE";
    filter_state_channel = "STATE_ESTIMATOR_STATE";

    publish_filter_state = true;
    publish_pose = true;
    republish_sensors = false;

    pose_render_frame = "body";

    # was this: 1000000 (1sec) for mav
    utime_history_span =1000000;

    ## starting position
    x0 {
        velocity = [0,0,0];
        angular_velocity = [0,0,0];
        position = [0, 0, 0];
        rpy = [0, 0, 0];
    }

    init_message {
        channel = "MAV_STATE_EST_INITIALIZER";
        downsample_factor = 1; # this should always be 1

        # if you give a value here, the state estimator will send a
        # timestamp over LCM when it completes its reset
        init_complete_channel = "MAV_STATE_EST_INIT_COMPLETE";

        roll_forward_on_receive = true;
        publish_head_on_message = true;

        utime_offset = 0;
    }

    history_span = 1.0;

    #initial state estimate standard deviations
    sigma0 {
        vb = 0.15; #m/s
        chi_xy = 3.0; #degrees
        chi_z = 3.0; #degrees
        Delta_xy = .5; #m
        Delta_z = 1;    #m

        gyro_bias = 0; # 0 #deg/seg initial certainty on bias values
        accel_bias = 0;# 0 #m/s^2 '' ''' '' '' 0 means that we think we have perfect knowledge of the bias
    }

    ins {
        channel = "attitude"; # "ATLAS_IMU_BATCH_FILTERED", "MICROSTRAIN_INS";
        utime_offset = 0; #units 1e-6 seconds
        downsample_factor = 1; # process 1 out of every this many. for 333Hz use 1. for 1kHz use 3
        roll_forward_on_receive = true;
        publish_head_on_message = true;

        # microstrain: 0.5 | 0.2 | 0 | 0
        # i always used 0.5 | 0.2 | 0 | 0
        q_gyro = 0.5; #deg/sec
        q_accel = 0.2; #m/s^2
        q_gyro_bias = 0; #deg/seg^2 | 0.001 suggested by charlie, but not deemed to be necessary
        q_accel_bias = 0; #m/sec^2/sec | 0.001 suggested by charlie and worked well on logs
        frame = "ardupilot2";

        #ms
        timestep_dt = 0.007142857; # REMEMBER TO CHANGE THIS IF YOU CHANGE THE IMU FREQUENCY or downsample factor

        num_to_init = 100; # was 100 for microstrain

        # apply notch filtering on input: (to atlas imu accel signals)
        atlas_filter = false;
        atlas_filter_freq = 87.0; # correct for after March 2014 work
    }

    gps{
      r_xy = 2.0; #2.0; #m
      #r_z = 2.0; #m
      r_z = 200.0; #m

      channel = "gps";
      #utime_offset = 273200; #.27 second delay optimized for on 11-05-03-outdoors.01
      #utime_offset = 145000; #.145 second delay from fixie-gps-2012-05-12.02
      utime_offset = 0;
      downsample_factor = 1; # process 1 out of every this many
    }

    airspeed{
        r = 15; #m/s (?)

        channel = "airspeed";

        utime_offset = 0;
        downsample_factor = 1; # process 1 out of every this many

        roll_forward_on_receive = false;
        publish_head_on_message = false;
    }

    altimeter{
        r = 5; #m -- altitude

        channel = "altimeter";

        utime_offset = 0;
        downsample_factor = 1; # process 1 out of every this many

        roll_forward_on_receive = false;
        publish_head_on_message = false;
    }

    sideslip{
        r = 5; #m/s

        channel = "sideslip";

        utime_offset = 0;
        downsample_factor = 1; # process 1 out of every this many

        roll_forward_on_receive = false;
        publish_head_on_message = false;
    }

}


gps_origin{
  latlon = [42.361561,-71.090634]; #outside of 32-380 on the brick area
  #elevation = 22;
  elevation = 0;

  #latlon = [42.357351,-71.099301]; #2nd base of baseball field next to track on Briggs
  #elevation = 0;

  #latlon=[ 42.35588476, -71.10487220, -24]; #lr3 origin for train tracks planning
  #elevation = -24;
}

lcm_channels{

    stereo_replay = "stereo_replay";
    gps = "gps";
    airspeed = "airspeed";
    airspeed_unchecked = "airspeed-unchecked";
    servo_out = "servo_out";
    battery_status = "battery-status";
    stereo_image_left = "stereo_image_left";
    stereo_image_right = "stereo_image_right";
    stereo_replay = "stereo_replay";
    stereo = "stereo";
    stereo_bm = "stereo-bm";
    stereo_with_xy = "stereo-octomap";
    octomap = "OCTOMAP";
    tvlqr_action = "tvlqr-action-out";

}

tvlqr_controller{

    # mapping between switch position and trajectory number

    number_of_switch_positions = 27;

    # values in micro seconds that denote different switches
    switch_rc_us = [
        1926, # switch position 0, 0, 0
        1906, # switch position 0, 0, 1
        1886, # switch position 0, 0, 2
        1866, # switch position 0, 1, 0
        1846, # switch position 0, 1, 1
        1826, # switch position 0, 1, 2
        1806, # switch position 0, 2, 0
        1786, # switch position 0, 2, 1
        1765, # switch position 0, 2, 2
        1514, # switch position 1, 0, 0
        1494, # switch position 1, 0, 1
        1474, # switch position 1, 0, 2
        1454, # switch position 1, 1, 0
        1434, # switch position 1, 1, 1
        1414, # switch position 1, 1, 2
        1394, # switch position 1, 2, 0
        1374, # switch position 1, 2, 1
        1354, # switch position 1, 2, 2
        1102, # switch position 2, 0, 0
        1082, # switch position 2, 0, 1
        1062, # switch position 2, 0, 2
        1042, # switch position 2, 1, 0
        1022, # switch position 2, 1, 1
        1002, # switch position 2, 1, 2
        982,  # switch position 2, 2, 0
        962,  # switch position 2, 2, 1
        942   # swtich position 2, 2, 2
    ];

    switch_mapping = [
        10000, # switch position 0, 0, 0 -- PD
        10001, # switch position 0, 0, 1 -- PD increased roll
        10002, # switch position 0, 0, 2 -- PD increased roll and pitch
        10003, # switch position 0, 1, 0 -- TILQR just roll and pitch
        10004, # switch position 0, 1, 1 -- TILQR roll pitch and yaw
        10005, # switch position 0, 1, 2 -- TILQR full
        0, # switch position 0, 2, 0 -- straight traj R = 35
        1, # switch position 0, 2, 1 -- straight traj R = 50
        2, # switch position 0, 2, 2 -- straight traj R = 25
        9, # switch position 1, 0, 0 -- right PD
        10, # switch position 1, 0, 1 -- right PD + yaw
        11, # switch position 1, 0, 2 -- right PD + aggressive yaw
        6, # switch position 1, 1, 0 -- right model
        7, # switch position 1, 1, 1 -- right model
        8, # switch position 1, 1, 2 -- right model
        10000, # switch position 1, 2, 0 --
        10000, # switch position 1, 2, 1 --
        10000, # switch position 1, 2, 2 --
        15, # switch position 2, 0, 0 -- climb PD
        16, # switch position 2, 0, 1 -- climb PD + yaw
        17, # switch position 2, 0, 2 -- climb PD + aggressive yaw
        12, # switch position 2, 1, 0 -- climb model
        13, # switch position 2, 1, 1 -- climb model
        14, # switch position 2, 1, 2 -- climb model
        10000, # switch position 2, 2, 0 --
        10000, # switch position 2, 2, 1 --
        10000  # swtich position 2, 2, 2 --
    ];

}
